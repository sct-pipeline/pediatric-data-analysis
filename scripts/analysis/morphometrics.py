import sys, os
import argparse
import glob
import numpy as np
from scipy.interpolate import interp1d
import pandas as pd
import spinalcordtoolbox.utils as sct
from spinalcordtoolbox.scripts import sct_process_segmentation, sct_label_vertebrae

"""
This script computes spinal cord morphometrics (e.g., CSA) from T2-weighted data.

- One CSV is saved per subject inside their folder.
- All CSVs are then merged into a global CSV file 

Usage : 
    The script can be run with `sct_run_batch` using the wrapper script `wrapper_rootlets.sh` as follows:
        
        sct_run_batch -config config/config_morphometrics.yaml -script wrappers/wrapper_morphometrics.sh

Author: Samuelle St-Onge
"""

def compute_morphometrics(level_type, output_csv_filename, participants_info, t2w_seg_file, label_file, levels, perlevel=0, perslice=0, pmj=None):
    """
    This function computes spinal cord morphometrics using `sct_process_segmentation`. 
    The output morphometrics are saved in a CSV file with the age and sex info for each subject, taken from the 1participants.tsv` file. 
    
    Args : 
        level_type: Either 'VertLevel' or 'SpinalLevel'
        output_csv_filename: Name of the output CSV file
        participants_info: Path to the `participants.tsv` file
        t2w_seg_file: Path to the spinal cord segmentation mask
        label_file: The labeled levels (either the labeled segmentation for vertebral levels, or the spinal level labels)
        vertlevels: The levels to compute the metrics across (i.e., 1:20)
        perlevel: Output either one metric per level (perlevel=1) or a single output metric for all levels (perlevel=0)
        perslice: Output either one metric per slice (perslice=1) or a single output metric for all slices (perslice=0)
        pmj: Path to the PMJ label
    """
    # Run sct_process_segmentation
    sct_process_segmentation.main([
        '-i', t2w_seg_file,
        '-vert', levels,
        '-vertfile', label_file,
        '-perlevel', perlevel,
        '-perslice', perslice,
        '-pmj', pmj,
        '-o', output_csv_filename
    ])

    # Load results in output CSV file 
    df = pd.read_csv(output_csv_filename)

    # Get the subject ID from the filename
    df['subject'] = 'sub-' + df['Filename'].astype(str).str.extract(r'sub-([0-9]+)')[0]

    # Get the age and sex from the `participants.tsv`` file, and add to the morphometrics CSV file 
    df_age = pd.read_csv(participants_info, sep='\t').rename(columns={'participant_id': 'subject'})
    df.columns = df.columns.str.strip()
    df_age.columns = df_age.columns.str.strip()

    df = df.drop(columns=[col for col in ['age', 'sex'] if col in df.columns])
    df_merged = df.merge(df_age[['subject', 'age', 'sex']], on='subject', how='left')

    # Rename columns and save the changes to the CSV file
    df_merged = df_merged.rename(columns={
        'VertLevel': level_type,
        'MEAN(area)': 'CSA',
        'MEAN(diameter_AP)': 'AP_diameter',
        'MEAN(diameter_RL)': 'RL_diameter',
        'MEAN(eccentricity)': 'eccentricity',
        'MEAN(solidity)': 'solidity'
    })

    df_merged.to_csv(output_csv_filename, index=False)


def compute_interpolated_morphometrics(data_path, path_output, output_csv_filename, level_type, t2w_pmj_label, t2w_seg_file, participants_info, final_csv_filename, subject):
    """
    This function interpolates PMJ distances at 0.1 intervals between each each Vertebral Level or Spinal Level.
    Then, morphometrics are computed for each distance (1.0, 1.1, 1.2, etc.), and the results are saved to a final CSV file.

    Args:
        output_csv_filename (str): Path to the CSV file containing morphometrics data (generated by the `compute_morphometrics` function above).
        path_output: Path to the output results
        level_type (tuple): Either 'VertLevel' or 'SpinalLevel' to determine the type of levels to interpolate.
        t2w_pmj_label : Path to the PMJ label file
        t2w_seg_file = Path to the T2w segmentation file
        participants_info : Path to the participants.tsv file
        final_csv_filename : The name of the output CSV file (containing the interpolated morphometrics)
        participants_info (str): Path to the TSV file containing participant information

    """

    csv_file = pd.read_csv(output_csv_filename)

    if level_type in csv_file.columns and 'DistancePMJ' in csv_file.columns:
        # Clean and sort
        df_sorted = csv_file[[level_type, 'DistancePMJ']].dropna().drop_duplicates().sort_values(by=level_type)
        levels = df_sorted[level_type].values
        pmj_distances = df_sorted['DistancePMJ'].values

        # Create interpolation function
        interp_func = interp1d(levels, pmj_distances, kind='linear', fill_value='extrapolate')

        # Generate 0.1 step levels between each integer level (excluding integer levels)
        interp_levels = []
        for i in range(int(levels.min()), int(levels.max())):
            interp_levels.extend(np.round(np.arange(i + 0.1, i + 1.0, 0.1), 1))

        interp_levels = np.array(interp_levels)
        interp_distances = interp_func(interp_levels)

        # Create interpolated DataFrame
        df_interp = pd.DataFrame({
            level_type: interp_levels,
            'DistancePMJ': interp_distances
        })

        # Add other morphometrics as NaN for interpolated levels
        morphometric_cols = [col for col in csv_file.columns if col not in [level_type, 'DistancePMJ']]
        for col in morphometric_cols:
            df_interp[col] = np.nan

        # Combine original + interpolated
        df_combined = pd.concat([csv_file, df_interp], ignore_index=True).sort_values(by=level_type).reset_index(drop=True)

        # Re-add subject column
        if 'subject' not in df_combined.columns:
            df_combined['subject'] = subject

        # Save final merged morphometrics with interpolated PMJ distances
        output_interp_csv = output_csv_filename.replace('.csv', f'_interpolated.csv')
        df_combined.to_csv(output_interp_csv, index=False)
        print(f"Updated morphometrics CSV with interpolated PMJ distances saved to:\n{output_interp_csv}")
    else:
        print(f"Missing {level_type} or DistancePMJ column â€” interpolation skipped.")

    # Create a list to store DataFrames for each distance from PMJ 
    all_results = []

    # Read the interpolated CSV file
    csv_file_interpolated = pd.read_csv(output_interp_csv)

    # Merge age and sex into the interpolated CSV before processing
    df_participants_info = pd.read_csv(participants_info, sep='\t').rename(columns={'participant_id': 'subject'})
    csv_file_interpolated = csv_file_interpolated.merge(df_participants_info[['subject', 'age', 'sex']], on='subject', how='left')

    # Iterate through each row in the interpolated CSV file and compute morphometrics for each PMJ distance (each VertLevel interval)
    for index, row in csv_file_interpolated.iterrows():
        level = row[level_type]
        distance_pmj = row['DistancePMJ']

        # Create a temporary file to store the result for each vert_level
        temp_csv_filename = os.path.join(path_output, f"{subject}_temp_pmj_{level_type}_{level}.csv")

        if os.path.exists(temp_csv_filename):
            print(f"Temporary file already exists: {temp_csv_filename}. Skipping processing for {level_type} {level} (PMJ distance: {distance_pmj})")
            continue

        # Call sct_process_segmentation
        sct_process_segmentation.main([
            '-i', t2w_seg_file,
            '-pmj', t2w_pmj_label,
            '-pmj-distance', str(distance_pmj),
            '-pmj-extent', '3',
            '-perlevel', '0',
            '-o', temp_csv_filename,
        ])

        # Read results from the temporary CSV file and append the values to a list (`all_results`)
        temp_df = pd.read_csv(temp_csv_filename)
        
        # Rename columns
        temp_df = temp_df.rename(columns={
            'MEAN(area)': 'CSA',
            'MEAN(diameter_AP)': 'AP_diameter',
            'MEAN(diameter_RL)': 'RL_diameter',
            'MEAN(eccentricity)': 'eccentricity',
            'MEAN(solidity)': 'solidity'
        })

        # Add subject, level type ('VertLevel' or 'SpinalLevel'), and DistancePMJ columns
        temp_df[level_type] = level
        temp_df['DistancePMJ'] = distance_pmj
        temp_df['subject'] = subject

        # Append to the results list (this list will then contain all morphometrics for each PMJ distance, i.e. from each temp CSV file)
        all_results.append(temp_df[['subject', 'VertLevel', 'DistancePMJ', 'CSA', 'AP_diameter', 'RL_diameter', 'eccentricity', 'solidity']])
        print(f"Processed VertLevel {level} (PMJ distance : {distance_pmj})")

    # Save all resuts to a final CSV file
    final_results_df = pd.concat(all_results, ignore_index=True)
    
    # Add age and sex columns to the final CSV file
    final_results_df = final_results_df.merge(df_participants_info[['subject', 'age', 'sex']], on='subject', how='left')
    
    # Save the final results to a CSV file
    final_results_df.to_csv(final_csv_filename, index=False)
    print(f"Final morphometrics results saved to:\n{final_csv_filename}")

    # Delete all temporary files
    temp_files_pattern = os.path.join(path_output, f"{subject}_temp_pmj_*.csv")
    temp_files = glob.glob(temp_files_pattern)

    for temp_file in temp_files:
        os.remove(temp_file)
        print(f"Deleted temp file: {temp_file}")


def main(subject, data_path, path_output, subject_dir, file_t2):

    # Define paths
    t2w_file = os.path.join(data_path, subject, "anat", f"{file_t2}.nii.gz")
    t2w_seg_file = os.path.join(subject_dir, f"{file_t2}_label-SC_mask.nii.gz")
    t2w_pmj_label = os.path.join(subject_dir, f"{file_t2}_label-PMJ_dlabel.nii.gz")
    t2w_disc_labels = os.path.join(subject_dir, f"{file_t2}_labels-disc_step1_levels.nii.gz")
    t2w_labeled_seg = os.path.join(subject_dir, f"{file_t2}_label-SC_mask_labeled.nii.gz")
    spinal_levels = os.path.join(subject_dir, f"{file_t2}_label-rootlets_dseg_modif_spinal_levels.nii.gz")
    output_csv_filename = os.path.join(path_output, f"{subject}_morphometrics.csv")
    participants_info = os.path.join(data_path, 'participants.tsv')

    # Check if the final CSV file already exists
    final_csv_filename_vertlevels = output_csv_filename.replace('.csv', 'vertlevels_final.csv')
    final_csv_filename_spinallevels = output_csv_filename.replace('.csv', 'spinallevels_final.csv')

    if os.path.exists(final_csv_filename_vertlevels):
        print(f"Final CSV already exists for subject {subject}: {final_csv_filename_vertlevels}. Skipping processing.")
        return
    else:
        print(f"Processing subject: {subject}")

    ########## FOR VERTEBRAL LEVELS ##########

    # 1. Label spinal cord with vertebral discs
    if os.path.exists(t2w_labeled_seg):
        print(f"SC mask already labeled: {os.path.basename(t2w_labeled_seg)}")
    else:
        print("Labeling SC mask...")
        sct_label_vertebrae.main([
            '-i', t2w_file,
            '-s', t2w_seg_file,
            '-c', 't2',
            '-discfile', t2w_disc_labels,
            '-ofolder', subject_dir
        ])

    # 2. Compute morphometrics per slice and per level
    compute_morphometrics(
        level_type = 'VertLevel',
        output_csv_filename=os.path.join(path_output, f"{subject}_vertlevel_morphometrics.csv"),
        participants_info=participants_info,
        t2w_seg_file=t2w_seg_file,
        label_file=t2w_labeled_seg, # Use the labeled segmentation 
        levels='1:20',
        perlevel='1',
        perslice='1',
        pmj=t2w_pmj_label
    )

    # 3. Interpolate PMJ distances for each Vertebral Level 
    compute_interpolated_morphometrics(data_path, 
                                       output_csv_filename=os.path.join(path_output, f"{subject}_vertlevel_morphometrics.csv"), 
                                       level_type='VertLevel', 
                                       t2w_pmj_label=t2w_pmj_label, 
                                       t2w_seg_file=t2w_seg_file, 
                                       participants_info=participants_info, 
                                       final_csv_filename=final_csv_filename_vertlevels, 
                                       subject=subject)

    ########## FOR SPINAL LEVELS ##########

    # Note : the spinal levels are extracted from the rootlets segmentation, in the rootlets.py script. This script has to be run previously to generate the spinal levels. 

    # 1. Compute morphometrics per slice and per level
    compute_morphometrics(
        level_type='SpinalLevel',
        output_csv_filename=os.path.join(path_output, f"{subject}_spinallevel_morphometrics.csv"),
        participants_info=participants_info,
        t2w_seg_file=t2w_seg_file,
        label_file=spinal_levels, # Use spinal levels 
        levels='1:8',
        perlevel='1',
        perslice='1',
        pmj=t2w_pmj_label
    )

    # 2. Interpolate PMJ distances for each Vertebral Level 
    compute_interpolated_morphometrics(data_path, 
                                       output_csv_filename=os.path.join(path_output, f"{subject}_spinallevel_morphometrics.csv"), 
                                       level_type='SpinalLevel', 
                                       t2w_pmj_label=t2w_pmj_label, 
                                       t2w_seg_file=t2w_seg_file, 
                                       participants_info=participants_info, 
                                       final_csv_filename=final_csv_filename_spinallevels, 
                                       subject=subject)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run morphometric extraction for one subject")
    parser.add_argument("--subject", required=True, help="Subject ID (e.g., sub-001)")
    parser.add_argument("--data-path", required=True, help="Path to raw data")
    parser.add_argument("--path-output", required=True, help="Path to output results")
    parser.add_argument("--subject-dir", required=True, help="Path to subject folder (e.g., sub-001)")
    parser.add_argument("--file-t2", required=True, help="T2-weighted image prefix (e.g., sub-01_T2w)")

    args = parser.parse_args()

    main(args.subject, args.data_path, args.path_output, args.subject_dir, args.file_t2)
