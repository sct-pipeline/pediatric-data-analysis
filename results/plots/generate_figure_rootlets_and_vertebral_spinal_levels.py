#!/usr/bin/env python
#
# This script was modified from the original script `generate_figure_rootlets_and_vertebral_spinal_levels.py` from the spinal rootlets model repository
# URL : https://github.com/ivadomed/model-spinal-rootlets/blob/main/pediatric_rootlets/generate_figure_rootlets_and_vertebral_spinal_levels.py  
# Authors : Katerina Krejci, Jan Valosek
# 
# The script is used to generate a figure showing the correspondence between spinal levels and vertebrae levels.
# The script also computes a distance from the PMJ to the middle of each spinal level. Results are saved to
# a CSV file.
#
# Usage:
#     python generate_figure_rootlets_vertebrae_spinal_levels.py -i /path/to/data_processed -participants /path/to/participants.tsv
#
# Modified by : Samuelle St-Onge

import os
import sys
import glob
import argparse
import pandas as pd
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.patheffects as pe
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import yaml

# Initialize dictionaries
AGE_TO_AXIS = {}
SUBJECT_TO_XTICKS = {}
LIST_OF_LEVEL_TYPES = ['rootlets', 'vertebrae']
XOFFSET = {'rootlets': -0.10, 'vertebrae': 0.10}
LEVEL_TYPE_COLOR = {'rootlets': 'red', 'vertebrae': 'blue'}
LEVEL_TYPES_TO_LEGEND = {'rootlets': 'spinal', 'vertebrae': 'vertebral'}
FONT_SIZE = 14

# Load config file to get path to dataset
with open('config/config_preprocessing.yaml' , 'r') as file:
    config = yaml.safe_load(file)
path_data = config['path_data']

# Define colormap for spinal levels (light red to dark red)
base_cmap_spinal = cm.get_cmap('Reds')
spinal_cmap = mcolors.LinearSegmentedColormap.from_list(
    'trunc_Reds', 
    base_cmap_spinal(np.linspace(0.3, 1.0, 8))  # 0.3 to skip white
)

# Define colormap for vertebral levels (light blue to dark blue)
base_cmap_vert = cm.get_cmap('Blues')
vertebral_cmap = mcolors.LinearSegmentedColormap.from_list(
    'trunc_Blues', 
    base_cmap_vert(np.linspace(0.3, 1.0, 8))  # 0.3 to skip white
)

def get_parser():
    """
    parser function
    """

    parser = argparse.ArgumentParser(
        description='Generate a figure showing the correspondence between the spinal and vertebral levels. The script also computes a distance from the PMJ to the middle of each spinal level and COV. Results are saved to a CSV file.',
        prog=os.path.basename(__file__).strip('.py')
    )
    parser.add_argument(
        '-i',
        required=True,
        type=str,
        help='Path to the data_processed folder with CSV files for individual subjects and method of level estimation generated by the '
             'inter-rater_variability/02a_rootlets_vertebrae_spinal_levels.py script.'
             'The figure will be saved to the same folder.'
    )
    parser.add_argument(
        '-participants',
        required=True,
        type=str,
        help='Path to the participants.tsv file.'
    )
    parser.add_argument(
        '-sex',
        required=False,
        type=str,
        help="Choose sex for the analysis. Options: 'M' or 'F'."
    )

    return parser


def generate_figure(df, dir_path, sex):
    """
    Generate a figure showing the average distances from PMJ of spinal and vertebral levels, for each age. 
    :param df: Pandas DataFrame with the data
    :param dir_path: Path to the data_processed folder
    :return: None
    """

    # Get list of subjects and their ages
    subjects = df['subject'].unique()
    ages = list(range(6, 18))

    # Compute the number of subjects per age
    subject_count_per_age = df.groupby('age')['subject'].nunique()

    # Map age values to x ticks
    AGE_TO_AXIS = {age: i + 1 for i, age in enumerate(ages)}
    AGE_TO_XTICKS = {age: str(age) for age in ages}

    fig = plt.figure(figsize=(len(ages), 6))
    ax = fig.add_subplot()

    # Add a background rectangle that covers the whole age range
    min_age_idx = min(AGE_TO_AXIS.values()) - 0.5
    max_age_idx = max(AGE_TO_AXIS.values()) + 0.5
    ax.add_patch(
        patches.Rectangle(
            (min_age_idx, 0),              # x, y
            max_age_idx - min_age_idx,      # width
            190,                            # height
            linewidth=0,
            facecolor='gray',
            alpha=0.05
        )
    )

    # Loop across ages and levels
    for age in ages:
        
        df_age = df[df['age'] == age]
        if df_age.empty:
            continue  # Skip plotting if no data for this age, but tick stays
        
        for level_type in LIST_OF_LEVEL_TYPES:
            levels = sorted(df['spinal_level'].unique())
            for level in levels:
                # Filter rows for this age, level type, and level
                rows = df[
                    (df['age'] == age) &
                    (df['level_type'] == level_type) &
                    (df['spinal_level'] == level)
                ]

                if rows.empty:
                    continue

                # Compute mean distance and height for this combination of age, level type and level
                mean_distance = rows['distance_from_pmj_end'].mean()
                mean_height = rows['height'].mean() # Corresponds to start - end distance

                # Determine color based on level type and level
                if level_type == 'vertebrae':
                    color = vertebral_cmap((level - 1) / 7)  # blue gradient by level
                else:
                    color = spinal_cmap((level - 1) / 7)  # red gradient by level

                # Plot average rectangle only
                ax.add_patch(
                    patches.Rectangle(
                        (AGE_TO_AXIS[age] + XOFFSET[level_type], mean_distance),
                        0.10,
                        mean_height,
                        color=color,
                        alpha=0.6,
                        linewidth=2,
                        edgecolor='black'
                    )
                )

                # Add number label at the center of rectangle
                ax.text(
                    AGE_TO_AXIS[age] + XOFFSET[level_type] + 0.05,
                    mean_distance + mean_height / 2,
                    int(level),
                    ha='center',
                    va='center',
                    fontsize=8,
                    color='white',
                    path_effects=[pe.withStroke(linewidth=1, foreground='black')]
                )

    # Axis settings
    ax.set_xlim(min_age_idx, max_age_idx)
    ax.set_ylim(0, 170)
    ax.set_ylim(ax.get_ylim()[::-1])  # Reverse Y-axis

    ax.set_xlabel('Age (years)', fontsize=FONT_SIZE)
    ax.xaxis.set_label_coords(0.5, -0.12)  # Adjust x-axis title position (centered below the custom labels showing the number of subjects per age)
    ax.set_ylabel('Distance from PMJ (mm)', fontsize=FONT_SIZE)
    ax.set_xticks([AGE_TO_AXIS[a] for a in ages])
    ax.set_xticklabels([str(a) for a in ages], fontsize=FONT_SIZE)
    ax.tick_params(axis='y', labelsize=FONT_SIZE - 4)
    ax.set_yticks(range(0, 170, 10))
    ax.grid(axis='y', alpha=0.2)
    ax.set_axisbelow(True)

    # Add labels for subject counts below the age ticks
    for age, x_pos in AGE_TO_AXIS.items():
        count = subject_count_per_age.get(age, 0)
        ax.text(
            x_pos,                  # x position 
            ax.get_ylim()[0] + 13,   # y position
            f'N={count}',
            ha='center',
            va='top',
            fontsize=FONT_SIZE - 3,
            color='black'
        )

    # Legend
    legend_handles = [
        patches.Patch(color=LEVEL_TYPE_COLOR[t], label=LEVEL_TYPES_TO_LEGEND[t], alpha=0.5)
        for t in LIST_OF_LEVEL_TYPES
    ]
    leg = ax.legend(handles=legend_handles, ncol=2, loc='upper center', bbox_to_anchor=(0.5, 1.12))
    ax.add_artist(leg)
    plt.setp(ax.get_legend().get_title(), fontsize=FONT_SIZE - 2)

    # Title and layout
    if sex == "F":
        ax.set_title('Spinal vs. Vertebral Levels (Female subjects)', pad=40)
    elif sex == "M":
        ax.set_title('Spinal vs. Vertebral Levels (Male subjects)', pad=40)
    else:
        ax.set_title('Spinal vs. Vertebral Levels', pad=40)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['bottom'].set_visible(True)

    plt.tight_layout()

    # Save figure
    figures_dir = os.path.abspath(os.path.join(dir_path, '../../figures/'))
    os.makedirs(figures_dir, exist_ok=True)
    fname_figure = f'figure_spinal_levels_vs_vertebral_levels_ages_{sex}.png'
    full_figure_path = os.path.join(figures_dir, fname_figure)
    fig.savefig(full_figure_path, dpi=300)
    print(f'Figure saved to {full_figure_path}')


def main():
    # Parse the command line arguments
    parser = get_parser()
    args = parser.parse_args()

    dir_path = os.path.abspath(args.i)

    if not os.path.isdir(dir_path):
        print(f'ERROR: {args.i} does not exist.')
        sys.exit(1)

    df_participants = pd.read_csv(args.participants, sep='\t')
    participants_age = df_participants[['participant_id', 'age']]
    participants_sex = df_participants[['participant_id', 'sex']]

    # Get all the CSV files in the directory generated by the 02a_rootlets_to_spinal_levels.py script
    csv_files = glob.glob(os.path.join(dir_path, '**', '*pmj_distance_*[vertebral_disc|rootlets].csv'), recursive=True)

    # if csv_files is empty, exit
    if len(csv_files) == 0:
        print(f'ERROR: No CSV files found in {dir_path}')

    # Initialize an empty list to store the parsed data
    parsed_data = []

    # Loop across CSV files and aggregate the results into pandas dataframe
    for csv_file in csv_files:
        df_file = pd.read_csv(csv_file)
        parsed_data.append(df_file)

    # Combine list of dataframes into one dataframe
    df = pd.concat(parsed_data)
    print(df)

    # Function to get the age of the subjects from the participants.tsv file 
    def get_age(x):
        filename = os.path.basename(x)  # e.g. 'sub-107_acq-top_run-1_T2w...'
        participant_id = filename.split('_')[0]    # split at the first underscore (e.g. 'sub-107')
        participant_id = participant_id.strip() 
        matching = participants_age[participants_age['participant_id'] == participant_id]
        if matching.empty:
            print(f"No matching 'age' value for {participant_id} from filename {filename}")
            return None
        return matching['age'].values[0]
    
    # Function to get the sex of the subjects from the participants.tsv file 
    def get_sex(x):
        filename = os.path.basename(x)  
        participant_id = filename.split('_')[0] 
        participant_id = participant_id.strip()
        matching = participants_sex[participants_sex['participant_id'] == participant_id]
        if matching.empty:
            print(f"No matching 'sex' value for {participant_id} from filename {filename}")
            return None
        return matching['sex'].values[0]

    # Get the age of the subjects
    df['age'] = df['fname'].apply(get_age)

    # Extract rootlets or vertebrae level type from the fname and add it as a column
    df['level_type'] = df['fname'].apply(
        lambda x: 'rootlets' if 'label-rootlets' in x else 'vertebrae'
    )

    # Extract subjectID from the fname and add it as a column
    df['subject'] = df['fname'].apply(lambda x: x.split('_')[0])

    # Extract spinal level (cervical 1-8) and vertebral level (1-8)
    df = df[((df['level_type'] == 'rootlets') & (df['spinal_level'].isin([1, 2, 3, 4, 5, 6, 7, 8]))) |
        ((df['level_type'] == 'vertebrae') & (df['spinal_level'].isin([1, 2, 3, 4, 5, 6, 7, 8])))]

    if args.sex not in ['M', 'F']:
        sex = "all"
    else:
        sex = f"{args.sex}"
        df['sex'] = df['fname'].apply(get_sex)

        # Filter by selected sex
        df = df[df['sex'] == args.sex]

    # Sort the DataFrame based on the age column
    df = df.sort_values('age').reset_index(drop=True)

    # Generate figure for all subjects (no sex filtering)
    generate_figure(df, dir_path, sex=sex)


if __name__ == '__main__':
    main()

